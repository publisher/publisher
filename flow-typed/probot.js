/**
 * Flowtype definitions for lol
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import OctokitApp from "@octokit/app";
import Octokit, { type Static, type Octokit$Options } from "@octokit/rest";
import Webhooks from "@octokit/webhooks";
import express from "express";
import Redis from "ioredis";
import { Server } from "http";

declare var NodeJS: any;

declare var EventEmitter: any;

declare var Logger$1: any;

// import { EventEmitter as EventEmitter } from "promise-events";

declare type Listener = (...args: any[]) => void;
declare class EventEmitter {
  static listenerCount(emitter: EventEmitter, type: string | number): number;
  static defaultMaxListeners: number;
  eventNames(): Array<string | number>;
  setMaxListeners(n: number): this;
  getMaxListeners(): number;
  emit(type: string | number, ...args: any[]): boolean;
  addListener(type: string | number, listener: Listener): this;
  on(type: string | number, listener: Listener): this;
  once(type: string | number, listener: Listener): this;
  prependListener(type: string | number, listener: Listener): this;
  prependOnceListener(type: string | number, listener: Listener): this;
  removeListener(type: string | number, listener: Listener): this;
  off(type: string | number, listener: Listener): this;
  removeAllListeners(type?: string | number): this;
  listeners(type: string | number): Listener[];
  listenerCount(type: string | number): number;
  rawListeners(type: string | number): Listener[];
}
declare class Logger mixins EventEmitter {
  constructor(options: Logger$LoggerOptions): this;
  addStream(stream: Logger$Stream): void;
  addSerializers(serializers: Logger$Serializers): void;
  child(options: Object, simple?: boolean): Logger;
  reopenFileStreams(): void;
  level(): number;
  level(value: Logger$LogLevel): void;
  levels(): number[];
  levels(name: number | string): number;
  levels(name: number | string, value: Logger$LogLevel): void;
  fields: any;
  src: boolean;

  /**
   * Returns a boolean: is the `trace` level enabled?
   *
   * This is equivalent to `log.isTraceEnabled()` or `log.isEnabledFor(TRACE)` in log4j.
   */
  trace(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  trace(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  trace(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  trace(format: any, ...params: any[]): void;

  /**
   * Returns a boolean: is the `debug` level enabled?
   *
   * This is equivalent to `log.isDebugEnabled()` or `log.isEnabledFor(DEBUG)` in log4j.
   */
  debug(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  debug(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  debug(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  debug(format: any, ...params: any[]): void;

  /**
   * Returns a boolean: is the `info` level enabled?
   *
   * This is equivalent to `log.isInfoEnabled()` or `log.isEnabledFor(INFO)` in log4j.
   */
  info(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  info(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  info(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  info(format: any, ...params: any[]): void;

  /**
   * Returns a boolean: is the `warn` level enabled?
   *
   * This is equivalent to `log.isWarnEnabled()` or `log.isEnabledFor(WARN)` in log4j.
   */
  warn(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  warn(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  warn(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  warn(format: any, ...params: any[]): void;

  /**
   * Returns a boolean: is the `error` level enabled?
   *
   * This is equivalent to `log.isErrorEnabled()` or `log.isEnabledFor(ERROR)` in log4j.
   */
  error(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  error(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  error(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  error(format: any, ...params: any[]): void;

  /**
   * Returns a boolean: is the `fatal` level enabled?
   *
   * This is equivalent to `log.isFatalEnabled()` or `log.isEnabledFor(FATAL)` in log4j.
   */
  fatal(): boolean;

  /**
   * Special case to log an `Error` instance to the record.
   * This adds an `err` field with exception details
   * (including the stack) and sets `msg` to the exception
   * message or you can specify the `msg`.
   */
  fatal(error: Error, ...params: any[]): void;

  /**
   * The first field can optionally be a "fields" object, which
   * is merged into the log record.
   *
   * To pass in an Error *and* other fields, use the `err`
   * field name for the Error instance.
   */
  fatal(obj: Object, ...params: any[]): void;

  /**
   * Uses `util.format` for msg formatting.
   */
  fatal(format: any, ...params: any[]): void;
}
declare var Logger: any;

declare var npm$namespace$Logger: {
  createLogger: typeof Logger$createLogger,
  safeCycles: typeof Logger$safeCycles,
  resolveLevel: typeof Logger$resolveLevel,
  TRACE: typeof Logger$TRACE,
  DEBUG: typeof Logger$DEBUG,
  INFO: typeof Logger$INFO,
  WARN: typeof Logger$WARN,
  ERROR: typeof Logger$ERROR,
  FATAL: typeof Logger$FATAL,
  levelFromName: typeof Logger$levelFromName,
  nameFromLevel: typeof Logger$nameFromLevel,
  stdSerializers: typeof Logger$stdSerializers,

  RingBuffer: typeof Logger$RingBuffer,
  RotatingFileStream: typeof Logger$RotatingFileStream,
};
declare var Logger$TRACE: number;

declare var Logger$DEBUG: number;

declare var Logger$INFO: number;

declare var Logger$WARN: number;

declare var Logger$ERROR: number;

declare var Logger$FATAL: number;

declare type Logger$LogLevelString =
  | "trace"
  | "debug"
  | "info"
  | "warn"
  | "error"
  | "fatal";

declare type Logger$LogLevel = Logger$LogLevelString | number;

declare var Logger$levelFromName: $ObjMapi<
  { [k: Logger$LogLevelString]: any },
  <name>(name) => number,
>;

declare var Logger$nameFromLevel: {
  [level: number]: string,
};

declare var Logger$stdSerializers: Logger$StdSerializers;

declare function Logger$createLogger(options: Logger$LoggerOptions): Logger;

declare function Logger$safeCycles(): (key: string, value: any) => any;

declare function Logger$resolveLevel(value: Logger$LogLevel): number;

declare interface Logger$Stream {
  type?: string;
  level?: Logger$LogLevel;
  path?: string;
  stream?: NodeJS.WritableStream | Logger$Stream;
  closeOnExit?: boolean;
  period?: string;
  count?: number;
  name?: string;
  reemitErrorEvents?: boolean;
}

declare interface Logger$LoggerOptions {
  name: string;
  streams?: Logger$Stream[];
  level?: Logger$LogLevel;
  stream?: NodeJS.WritableStream;
  serializers?: Logger$Serializers;
  src?: boolean;
  [custom: string]: any;
}

declare type Logger$Serializer = (input: any) => any;

declare interface Logger$Serializers {
  [key: string]: Logger$Serializer;
}

declare type Logger$StdSerializers = {
  err: Logger$Serializer,
  res: Logger$Serializer,
  req: Logger$Serializer,
} & Logger$Serializers;

declare interface Logger$RingBufferOptions {
  limit?: number;
}

declare class Logger$RingBuffer mixins EventEmitter {
  constructor(options: Logger$RingBufferOptions): this;
  writable: boolean;
  records: any[];
  write(record: any): boolean;
  end(record?: any): void;
  destroy(): void;
  destroySoon(): void;
}

declare interface Logger$RotatingFileStreamOptions {
  path: string;
  count?: number;
  period?: string;
}

declare class Logger$RotatingFileStream mixins EventEmitter {
  constructor(options: Logger$RotatingFileStreamOptions): this;
  writable: boolean;
  periodNum: number;
  periodScope: string;
  stream: any;
  rotQueue: any[];
  rotating: boolean;
  write(record: any): boolean;
  end(record?: any): void;
  destroy(): void;
  destroySoon(): void;
  rotate(): void;
}
declare interface Cache {
  wrap<T>(
    key: string,
    wrapper: (callback: (error: any, result: T) => void) => any,
    options: CacheConfig,
  ): Promise<any>;
}
declare interface CacheConfig {
  ttl: number;
}
/**
 * the [@octokit/rest Node.js module](https://github.com/octokit/rest.js),
 * which wraps the [GitHub API](https://developer.github.com/v3/) and allows
 * you to do almost anything programmatically that you can do through a web
 * browser.
 * @see {@link https://github.com/octokit/rest.js}
 */
declare function GitHubAPI(options?: Options): GitHubAPIType;
declare type Options = {
  debug?: boolean,
  logger: Logger$1,
  Octokit: Static,
} & Octokit$Options;
declare type Paginate = {
  (
    responsePromise: Promise<Octokit$AnyResponse>,
    callback?: (response: Octokit$AnyResponse) => any,
  ): Promise<any[]>,
};
//& Octokit$Paginate;
declare type Graphql = (
  query: string,
  variables?: Variables,
  headers?: Headers,
) => Promise<GraphQlQueryResponse>;
declare type GitHubAPIType = {
  paginate: Paginate,
  graphql: Graphql,

  /**
   * .query() is deprecated, use .gaphql() instead
   */
  query: Graphql,
} & Octokit;
declare interface GraphQlQueryResponse {
  data: {
    [key: string]: any,
  } | null;
  errors?: [
    {
      message: string,
      path: [string],
      extensions: {
        [key: string]: any,
      },
      locations: [
        {
          line: number,
          column: number,
        },
      ],
    },
  ];
}
declare interface Headers {
  [key: string]: string;
}
declare interface Variables {
  [key: string]: any;
}
declare type LoggerWithTarget = {
  (): boolean,
  (...params: any[]): void,
  target: Logger$1,
  child: (attrs: ChildArgs) => LoggerWithTarget,
  trace: LoggerWithTarget,
  debug: LoggerWithTarget,
  info: LoggerWithTarget,
  warn: LoggerWithTarget,
  error: LoggerWithTarget,
  fatal: LoggerWithTarget,
} & Logger$1;
declare interface ChildArgs {
  options?: { [key: string]: any };
  name?: string;
  id?: string | number | string[];
  installation?: string;
}
/**
 * The context of the event that was triggered, including the payload and
 * helpers for extracting information can be passed to GitHub API calls.
 *
 *   ```js
 *  *  module.exports = app => {
 *  *    app.on('push', context => {
 *  *      context.log('Code was pushed to the repo, what should we do with it?');
 *  *    });
 *  *  };
 *  *  ```
 * @property {github} github - A GitHub API client
 * @property {payload} payload - The webhook event payload
 * @property {logger} log - A logger
 */
declare type Context<E> = Webhooks$WebhookEvent<E> & {
  name: string,
  id: string,
  payload: E,
  protocol: "http" | "https",
  host: string,
  url: string,
  github: GitHubAPIType,
  log: LoggerWithTarget,
  // constructor(
  //   event: Webhooks$WebhookEvent<E>,
  //   github: GitHubAPIType,
  //   log: LoggerWithTarget
  // ): this,
  event: string,

  /**
   * Return the `owner` and `repo` params for making API requests against a
   * repository.
   *
   * ```js
   *    * const params = context.repo({path: '.github/config.yml'})
   *    * // Returns: {owner: 'username', repo: 'reponame', path: '.github/config.yml'}
   *    * ```
   * @param object - Params to be merged with the repo params.
   */
  repo<T>(
    object?: T,
  ): {
    owner: string,
    repo: string,
  } & T,

  /**
   * Return the `owner`, `repo`, and `number` params for making API requests
   * against an issue or pull request. The object passed in will be merged with
   * the repo params.
   *
   * ```js
   *    * const params = context.issue({body: 'Hello World!'})
   *    * // Returns: {owner: 'username', repo: 'reponame', number: 123, body: 'Hello World!'}
   *    * ```
   * @param object - Params to be merged with the issue params.
   */
  issue<T>(
    object?: T,
  ): {
    number: any,
  } & {
    owner: string,
    repo: string,
  } & T,

  /**
   * Returns a boolean if the actor on the event was a bot.
   * @type {boolean}
   */
  isBot: boolean,

  /**
   * Reads the app configuration from the given YAML file in the `.github`
   * directory of the repository.
   *
   * For example, given a file named `.github/config.yml`:
   *
   * ```yml
   *    * close: true
   *    * comment: Check the specs on the rotary girder.
   *    * ```
   *
   * Your app can read that file from the target repository:
   *
   * ```js
   *    * // Load config from .github/config.yml in the repository
   *    * const config = await context.config('config.yml')
   *    *
   *    * if (config.close) {
   *    *   context.github.issues.comment(context.issue({body: config.comment}))
   *    *   context.github.issues.edit(context.issue({state: 'closed'}))
   *    * }
   *    * ```
   *
   * You can also use a `defaultConfig` object:
   *
   * ```js
   *    * // Load config from .github/config.yml in the repository and combine with default config
   *    * const config = await context.config('config.yml', {comment: 'Make sure to check all the specs.'})
   *    *
   *    * if (config.close) {
   *    *   context.github.issues.comment(context.issue({body: config.comment}));
   *    *   context.github.issues.edit(context.issue({state: 'closed'}))
   *    * }
   *    * ```
   * @param fileName - Name of the YAML file in the `.github` directory
   * @param defaultConfig - An object of default config options
   * @return Configuration object read from the file
   */
  config<T>(fileName: string, defaultConfig?: T): Promise<any>,
};
declare interface Options$1 {
  app: OctokitApp;
  cache: Cache;
  router?: express.Router;
  catchErrors?: boolean;
  githubToken?: string;
  throttleOptions?: any;
  Octokit?: Static;
}
declare type OnCallback<T> = (context: Context<T>) => Promise<void>;
/**
 * The `app` parameter available to `ApplicationFunction`s
 * @property {logger} log - A logger
 */
declare class Application {
  events: EventEmitter;
  app: OctokitApp;
  cache: Cache;
  router: express.Router;
  log: LoggerWithTarget;
  constructor(options?: Options$1): this;

  /**
   * Loads an ApplicationFunction into the current Application
   * @param appFn - Probot application function to load
   */
  load(appFn: ApplicationFunction | ApplicationFunction[]): Application;
  receive(event: Webhooks$WebhookEvent<any>): Promise<[void, void, void]>;

  /**
   * Get an {@link http://expressjs.com|express} router that can be used to
   * expose HTTP endpoints
   *
   * ```
   *    * module.exports = app => {
   *    *   // Get an express router to expose new HTTP endpoints
   *    *   const route = app.route('/my-app');
   *    *
   *    *   // Use any middleware
   *    *   route.use(require('express').static(__dirname + '/public'));
   *    *
   *    *   // Add a new route
   *    *   route.get('/hello-world', (req, res) => {
   *    *     res.end('Hello World');
   *    *   });
   *    * };
   *    * ```
   * @param path - the prefix for the routes
   * @returns an [express.Router](http://expressjs.com/en/4x/api.html#router)
   */
  route(path?: string): express.Router;

  /**
   * Listen for [GitHub webhooks](https://developer.github.com/webhooks/),
   * which are fired for almost every significant action that users take on
   * GitHub.
   * @param event - the name of the [GitHub webhook
   * event](https://developer.github.com/webhooks/#events). Most events also
   * include an "action". For example, the * [`issues`](
   * https://developer.github.com/v3/activity/events/types/#issuesevent)
   * event has actions of `assigned`, `unassigned`, `labeled`, `unlabeled`,
   * `opened`, `edited`, `milestoned`, `demilestoned`, `closed`, and `reopened`.
   * Often, your bot will only care about one type of action, so you can append
   * it to the event name with a `.`, like `issues.closed`.
   *
   * ```js
   *    * app.on('push', context => {
   *    *   // Code was just pushed.
   *    * });
   *    *
   *    * app.on('issues.opened', context => {
   *    *   // An issue was just opened.
   *    * });
   *    * ```
   * @param callback - a function to call when the
   * webhook is received.
   */
  on(
    event:
      | "check_run"
      | "check_run.completed"
      | "check_run.created"
      | "check_run.requested_action"
      | "check_run.rerequested",
    callback: OnCallback<Webhooks$WebhookPayloadCheckRun>,
  ): void;
  on(
    event:
      | "check_suite"
      | "check_suite.completed"
      | "check_suite.requested"
      | "check_suite.rerequested",
    callback: OnCallback<Webhooks$WebhookPayloadCheckSuite>,
  ): void;
  on(
    event: "commit_comment" | "commit_comment.created",
    callback: OnCallback<Webhooks$WebhookPayloadCommitComment>,
  ): void;
  on(
    event: "create",
    callback: OnCallback<Webhooks$WebhookPayloadCreate>,
  ): void;
  on(
    event: "delete",
    callback: OnCallback<Webhooks$WebhookPayloadDelete>,
  ): void;
  on(
    event: "deployment",
    callback: OnCallback<Webhooks$WebhookPayloadDeployment>,
  ): void;
  on(
    event: "deployment_status",
    callback: OnCallback<Webhooks$WebhookPayloadDeploymentStatus>,
  ): void;
  on(event: "fork", callback: OnCallback<Webhooks$WebhookPayloadFork>): void;
  on(
    event: "github_app_authorization",
    callback: OnCallback<Webhooks$WebhookPayloadGithubAppAuthorization>,
  ): void;
  on(
    event: "gollum",
    callback: OnCallback<Webhooks$WebhookPayloadGollum>,
  ): void;
  on(
    event: "installation" | "installation.created" | "installation.deleted",
    callback: OnCallback<Webhooks$WebhookPayloadInstallation>,
  ): void;
  on(
    event:
      | "installation_repositories"
      | "installation_repositories.added"
      | "installation_repositories.removed",
    callback: OnCallback<Webhooks$WebhookPayloadInstallationRepositories>,
  ): void;
  on(
    event:
      | "issue_comment"
      | "issue_comment.created"
      | "issue_comment.deleted"
      | "issue_comment.edited",
    callback: OnCallback<Webhooks$WebhookPayloadIssueComment>,
  ): void;
  on(
    event:
      | "issues"
      | "issues.assigned"
      | "issues.closed"
      | "issues.deleted"
      | "issues.demilestoned"
      | "issues.edited"
      | "issues.labeled"
      | "issues.milestoned"
      | "issues.opened"
      | "issues.reopened"
      | "issues.transferred"
      | "issues.unassigned"
      | "issues.unlabeled",
    callback: OnCallback<Webhooks$WebhookPayloadIssues>,
  ): void;
  on(
    event: "label" | "label.created" | "label.deleted" | "label.edited",
    callback: OnCallback<Webhooks$WebhookPayloadLabel>,
  ): void;
  on(
    event:
      | "marketplace_purchase"
      | "marketplace_purchase.cancelled"
      | "marketplace_purchase.changed"
      | "marketplace_purchase.pending_change"
      | "marketplace_purchase.pending_change_cancelled"
      | "marketplace_purchase.purchased",
    callback: OnCallback<Webhooks$WebhookPayloadMarketplacePurchase>,
  ): void;
  on(
    event: "member" | "member.added" | "member.deleted" | "member.edited",
    callback: OnCallback<Webhooks$WebhookPayloadMember>,
  ): void;
  on(
    event: "membership" | "membership.added" | "membership.removed",
    callback: OnCallback<Webhooks$WebhookPayloadMembership>,
  ): void;
  on(
    event:
      | "milestone"
      | "milestone.closed"
      | "milestone.created"
      | "milestone.deleted"
      | "milestone.edited"
      | "milestone.opened",
    callback: OnCallback<Webhooks$WebhookPayloadMilestone>,
  ): void;
  on(
    event:
      | "organization"
      | "organization.member_added"
      | "organization.member_invited"
      | "organization.member_removed",
    callback: OnCallback<Webhooks$WebhookPayloadOrganization>,
  ): void;
  on(
    event: "org_block" | "org_block.blocked" | "org_block.unblocked",
    callback: OnCallback<Webhooks$WebhookPayloadOrgBlock>,
  ): void;
  on(
    event: "page_build",
    callback: OnCallback<Webhooks$WebhookPayloadPageBuild>,
  ): void;
  on(
    event:
      | "project_card"
      | "project_card.converted"
      | "project_card.created"
      | "project_card.deleted"
      | "project_card.edited"
      | "project_card.moved",
    callback: OnCallback<Webhooks$WebhookPayloadProjectCard>,
  ): void;
  on(
    event:
      | "project_column"
      | "project_column.created"
      | "project_column.deleted"
      | "project_column.edited"
      | "project_column.moved",
    callback: OnCallback<Webhooks$WebhookPayloadProjectColumn>,
  ): void;
  on(
    event:
      | "project"
      | "project.closed"
      | "project.created"
      | "project.deleted"
      | "project.edited"
      | "project.reopened",
    callback: OnCallback<Webhooks$WebhookPayloadProject>,
  ): void;
  on(
    event: "public",
    callback: OnCallback<Webhooks$WebhookPayloadPublic>,
  ): void;
  on(
    event:
      | "pull_request"
      | "pull_request.assigned"
      | "pull_request.closed"
      | "pull_request.edited"
      | "pull_request.labeled"
      | "pull_request.opened"
      | "pull_request.reopened"
      | "pull_request.review_request_removed"
      | "pull_request.review_requested"
      | "pull_request.unassigned"
      | "pull_request.unlabeled"
      | "pull_request.synchronize"
      | "pull_request.ready_for_review",
    callback: OnCallback<Webhooks$WebhookPayloadPullRequest>,
  ): void;
  on(
    event:
      | "pull_request_review"
      | "pull_request_review.dismissed"
      | "pull_request_review.edited"
      | "pull_request_review.submitted",
    callback: OnCallback<Webhooks$WebhookPayloadPullRequestReview>,
  ): void;
  on(
    event:
      | "pull_request_review_comment"
      | "pull_request_review_comment.created"
      | "pull_request_review_comment.deleted"
      | "pull_request_review_comment.edited",
    callback: OnCallback<Webhooks$WebhookPayloadPullRequestReviewComment>,
  ): void;
  on(event: "push", callback: OnCallback<Webhooks$WebhookPayloadPush>): void;
  on(
    event: "release" | "release.published",
    callback: OnCallback<Webhooks$WebhookPayloadRelease>,
  ): void;
  on(
    event:
      | "repository"
      | "repository.archived"
      | "repository.created"
      | "repository.deleted"
      | "repository.privatized"
      | "repository.publicized"
      | "repository.unarchived",
    callback: OnCallback<Webhooks$WebhookPayloadRepository>,
  ): void;
  on(
    event: "repository_import",
    callback: OnCallback<Webhooks$WebhookPayloadRepositoryImport>,
  ): void;
  on(
    event:
      | "repository_vulnerability_alert"
      | "repository_vulnerability_alert.create"
      | "repository_vulnerability_alert.dismiss"
      | "repository_vulnerability_alert.resolve",
    callback: OnCallback<Webhooks$WebhookPayloadRepositoryVulnerabilityAlert>,
  ): void;
  on(
    event:
      | "security_advisory"
      | "security_advisory.performed"
      | "security_advisory.published"
      | "security_advisory.updated",
    callback: OnCallback<Webhooks$WebhookPayloadSecurityAdvisory>,
  ): void;
  on(
    event: "status",
    callback: OnCallback<Webhooks$WebhookPayloadStatus>,
  ): void;
  on(
    event:
      | "team"
      | "team.added_to_repository"
      | "team.created"
      | "team.deleted"
      | "team.edited"
      | "team.removed_from_repository",
    callback: OnCallback<Webhooks$WebhookPayloadTeam>,
  ): void;
  on(
    event: "team_add",
    callback: OnCallback<Webhooks$WebhookPayloadTeamAdd>,
  ): void;
  on(
    event: "watch" | "watch.started",
    callback: OnCallback<Webhooks$WebhookPayloadWatch>,
  ): void;
  on(eventName: string[], callback: OnCallback<any>): void;

  /**
   * Authenticate and get a GitHub client that can be used to make API calls.
   *
   * You'll probably want to use `context.github` instead.
   *
   * **Note**: `app.auth` is asynchronous, so it needs to be prefixed with a
   * [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)
   * to wait for the magic to happen.
   *
   * ```js
   *    *  module.exports = (app) => {
   *    *    app.on('issues.opened', async context => {
   *    *      const github = await app.auth();
   *    *    });
   *    *  };
   *    * ```
   * @param id - ID of the installation, which can be extracted from
   * `context.payload.installation.id`. If called without this parameter, the
   * client wil authenticate [as the app](https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/#authenticating-as-a-github-app)
   * instead of as a specific installation, which means it can only be used for
   * [app APIs](https://developer.github.com/v3/apps/).
   * @returns An authenticated GitHub API client
   * @private
   */
  auth(id?: number, log?: LoggerWithTarget): Promise<GitHubAPIType>;
}
declare class Probot {
  static run(appFn: ApplicationFunction | string[]): Promise<Probot>;
  server: express.Application;
  httpServer: Server;
  webhook: Webhooks;
  logger: Logger$1;
  options: Options$2;
  app: OctokitApp;
  throttleOptions: any;
  constructor(options: Options$2): this;
  errorHandler(err: Error): void;
  receive(event: Webhooks$WebhookEvent<any>): Promise<[void, void, void][]>;
  load(appFn: string | ApplicationFunction): Application;
  setup(appFns: Array<string | ApplicationFunction>): void;
  start(): void;
}
declare var createProbot: (options: Options$2) => Probot;
declare type ApplicationFunction = (app: Application) => void;
declare interface Options$2 {
  webhookPath?: string;
  secret?: string;
  id?: number;
  cert?: string;
  githubToken?: string;
  webhookProxy?: string;
  port?: number;
  redisConfig?: Redis.RedisOptions;
  Octokit?: Static;
}

declare module "probot" {
  declare export {
    Application,
    // ApplicationFunctionType,
    // Context,
    Logger$1 as Logger,
    // Options$2 as Options,
    Probot,
    createProbot,
  };
}
